"""
    The evaluator for LegoNE code generated by the LLMs.
"""

from typing import Callable
from auto_design.prompts import (
    NUM_PLAYER_DECLARE,
    BUILDING_BLOCKS,
    INHERENT_CONSTRAINTS,
)
import subprocess
import os


def get_approximation(wolfram_output: str):
    # very adhoc, but very useful here
    # Find the last non-empty line in the output
    lines = wolfram_output.strip().split("\n")
    last_line = next(line for line in reversed(lines) if line.strip())
    return float(last_line[0:9]) + 1e-6


class Evaluator(object):
    """Evaluates LegoNE code by compiling and calculating approximation bound.
    
    This class handles the pipeline of:
    1. Generating complete LegoNE code from algorithm snippets
    2. Compiling LegoNE to Mathematica code
    3. Computing approximation bound using Mathematica
    
    Args:
        compiler_path (str): Path to the LegoNE compiler executable
        optimizer_name (str, optional): Name of Mathematica executable. Defaults to "wolframscript"
        logger (Callable[[str], None], optional): Function for logging output. 
            Defaults to no-op function.
    """

    def __init__(
        self,
        compiler_path: str,
        optimizer_name: str = "wolframscript",
        logger: Callable[[str], None] = lambda msg: None,
    ):
        self.optimizer_name = optimizer_name
        self.temp_legone_name = "__eval_temp.legone"
        self.temp_wolfram_name = "__eval_temp.m"
        self.compiler_args = [
            compiler_path,
            self.temp_legone_name,
            "-o",
            self.temp_wolfram_name,
        ]
        self.optimizer_args = [
            optimizer_name,
            "-file",
            self.temp_wolfram_name,
            "-l",
            "-print",
        ]
        self.logger = logger
        self.logger(
            "\033[1;95mInitializing Evaluator with the following configuration:\033[0m\n"
        )
        self.logger(f"optimizer_name: {self.optimizer_name}")
        self.logger(f"compiler_path: {compiler_path}")
        self.logger(f"temp_legone_name: {self.temp_legone_name}")
        self.logger(f"temp_wolfram_name: {self.temp_wolfram_name}")
        self.logger("compiler_args: " + str(self.compiler_args))
        self.logger("optimizer_args: " + str(self.optimizer_args) + "\n")

    def gen_legone_code(self, algo_code: str):
        self.logger("\033[1;95mEvaluator is generating LegoNE code...\033[0m")
                # check if both player has at most three strategies
        p1_count = algo_code.replace(" ", "").count(":p1")
        p2_count = algo_code.replace(" ", "").count(":p2")
        if p1_count > 3 or p2_count > 3:
                self.logger("\033[1;91mFailed. Each player can have at most 3 strategies. Cannot use!\033[0m")
                return "Each player can have at most 3 strategies. Cannot use!"
        legone_code = (
            NUM_PLAYER_DECLARE + BUILDING_BLOCKS + INHERENT_CONSTRAINTS + algo_code
        )
        with open(self.temp_legone_name, "w") as f:
            f.write(legone_code)
        self.logger(
            f"""\033[1;92mSucceeded. Evaluator has generated the following LegoNE code:\033[0m
\033[1;92m{' LegoNE code begins '.center(100, '=')}\033[0m
"""
        )
        self.logger(legone_code)
        self.logger(f"\033[1;92m{' LegoNE code ends '.center(100, '=')}\033[0m\n")

        return None


    def gen_wolfram_code(self):
        self.logger("\033[1;95mEvaluator is generating mathematica code...\033[0m")
        try:
            # Run the compiler to generate Wolfram code
            compiler_process = subprocess.run(
                self.compiler_args,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )

            # Check for errors in the compiler output
            if compiler_process.stderr or compiler_process.returncode != 0:
                stderr = compiler_process.stderr
                if not stderr:
                    self.logger(
                        "\033[1;91mFailed. Evaluator encounters a unknown system-level error\033[0m"
                    )
                    return "Unknown system-level error"
                if "std::runtime_error" in stderr:
                    err_str = stderr[
                        stderr.index("runtime_error: ") + len("runtime_error: ") :
                    ]
                    self.logger(
                        f"\033[1;91mFailed. Evaluator encounters a compile error: {err_str}\033[0m"
                    )
                    return err_str
                else:
                    self.logger(
                        f"\033[1;91mFailed. Evaluator encounters an inherent error in the compiler: {stderr}\033[0m"
                    )
                    return f"Unknown inherent error in the compiler: {stderr}"

            # If no errors, record the output and return None
            with open(self.temp_wolfram_name, "r") as f:
                self.logger(
                    f"""\033[1;92mSucceeded. Evaluator has generated the following mathematica code:\033[0m
\033[1;92m{' mathematica code begins '.center(100, '=')}\033[0m
"""
                )
                self.logger(f.read())
                self.logger(f"\033[1;92m{' mathematica code ends '.center(100, '=')}\033[0m\n")

            return None

        except Exception as e:
            # Catch any unexpected exceptions and return as unknown error
            self.logger(
                f"\033[1;91mFailed. Evaluator encounters unknown error: {e}\033[0m"
            )
            return f"Unknown error: {str(e)}"

    def cal_approx(self):
        self.logger(
            "\033[1;95mEvaluator is computing the approximation of the generated algorithm...\033[0m"
        )
        try:
            # Run the optimizer to calculate approximation bound
            optimizer_process = subprocess.run(
                self.optimizer_args,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )
            # Check for errors in the optimizer output
            if optimizer_process.stderr or optimizer_process.returncode != 0:
                stderr = optimizer_process.stderr
                if not stderr:
                    self.logger(
                        "\033[1;91mFailed. Evaluator encounters a unknown system-level error\033[0m"
                    )
                    return "Unknown system-level error"
                self.logger(
                    f"\033[1;91mFailed. Evaluator encounters a runtime error: {stderr}\033[0m"
                )
                return f"Unknown error: {stderr}"

            # If no errors, record the output and return None
            wolfram_output = optimizer_process.stdout
            self.logger(
                f"""\033[1;92mSucceeded. Here is the output of mathematica:\033[0m
\033[1;92m{' mathematica output begins '.center(100, '=')}\033[0m
"""
            )
            self.logger(wolfram_output)
            self.logger(f"\033[1;92m{' mathematica output ends '.center(100, '=')}\033[0m\n")
            self.approximation = get_approximation(wolfram_output)
            self.logger(
                f"\033[1;92mEvaluator got approximation: {self.approximation}\033[0m"
            )
            if self.approximation <= 1e-4:
                self.logger("\033[1;93mWarning: Mathematica may fail to converge...Try again\033[0m")
                # try again
                self.approximation = get_approximation(wolfram_output)
                self.logger(
                f"\033[1;92mEvaluator got approximation: {self.approximation}\033[0m"
                )
                if self.approximation <= 1e-4:
                    self.logger("\033[1;93mWarning: Mathematica may fail to converge for the second trial\033[0m")
                    return "Got approximation 0.0. It indicates that the computation may fail to converge. Try simpler algorithm."
            
            return None

        except Exception as e:
            # Catch any unexpected exceptions and return as unknown error
            self.logger(
                f"\033[1;91mFailed. Evaluator encounters unknown error: {e}\033[0m"
            )
            return f"Unknown error: {str(e)}"

    def clear_temp_files(self):
        try:
            os.remove(self.temp_legone_name)
        except:
            pass
        try:
            os.remove(self.temp_wolfram_name)
        except:
            pass

    def eval(self, algo_code: str):
        """Evaluate a LegoNE algorithm code snippet.
        
        This is the main public interface for evaluation. It:
        1. Generates complete LegoNE code
        2. Compiles to Mathematica
        3. Calculates approximation bound
        4. Cleans up temporary files
        
        Args:
            algo_code (str): The LegoNE algorithm code snippet to evaluate

        Returns:
            tuple[Literal[False], str] | tuple[Literal[True], float]: A tuple where:
                - If evaluation fails: (False, error_message)
                - If evaluation succeeds: (True, approximation_bound)
        """
        # First generate legone code
        gen_code_error = self.gen_legone_code(algo_code)
        if gen_code_error:
            return False, gen_code_error

        # Then compile to wolfram code
        compile_error = self.gen_wolfram_code()
        if compile_error:
            self.clear_temp_files()
            return False, compile_error

        # Finally calculate approximation bound
        calc_error = self.cal_approx()

        self.clear_temp_files()
        if calc_error:
            return False, calc_error

        return True, self.approximation


# class Evaluator
