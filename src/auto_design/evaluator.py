"""
    The evaluator for LegoNE code generated by the LLMs.
"""

from prompts import NUM_PLAYER_DECLARE, BUILDING_BLOCKS, INHERENT_CONSTRAINTS
import subprocess
import os
import re


def get_approximation(wolfram_output: str):
    # very adhoc, but very useful here
    return float(wolfram_output[1:10]) + 1e-7


class Evaluator(object):
    """
    The evaluator class.
    """

    def __init__(self, compiler_path: str, optimizer_name: str = "wolframscript"):
        self.optimizer_name = optimizer_name
        self.temp_legone_name = "__eval_temp.legone"
        self.temp_wolfram_name = "__eval_temp.m"
        self.compiler_args = [
            compiler_path,
            self.temp_legone_name,
            "-o",
            self.temp_wolfram_name,
        ]
        self.optimizer_args = [
            optimizer_name,
            "-file",
            self.temp_wolfram_name,
            "-l",
            "-print",
        ]

    def gen_legone_code(self, algo_code: str):
        self.legone_code = (
            NUM_PLAYER_DECLARE + BUILDING_BLOCKS + INHERENT_CONSTRAINTS + algo_code
        )
        with open(self.temp_legone_name, "w") as f:
            f.write(self.legone_code)

    def gen_wolfram_code(self):
        try:
            # Run the compiler to generate Wolfram code
            compiler_process = subprocess.run(
                self.compiler_args,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )

            # Check for errors in the compiler output
            if compiler_process.stderr or compiler_process.returncode != 0:
                # Clean up temporary LegoNE and Wolfram files before returning error
                try:
                    os.remove(self.temp_legone_name)
                    os.remove(self.temp_wolfram_name)
                except:
                    pass
                stderr = compiler_process.stderr
                if not stderr:
                    return "Unknown system-level error"
                if "std::runtime_error" in stderr:
                    return stderr[stderr.index("runtime_error: ") + len("runtime_error: "):]
                else:
                    return f"Unknown error: {stderr}"

            # If no errors, record the output in the class and return None
            with open(self.temp_wolfram_name, "r") as f:
                self.wolfram_code = f.read()

            return None

        except Exception as e:
            # Catch any unexpected exceptions and return as unknown error
            return f"Unknown error: {str(e)}"

    def cal_approx(self):
        try:
            # Run the optimizer to calculate approximation ratio
            optimizer_process = subprocess.run(
                self.optimizer_args,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )

            # Check for errors in the optimizer output
            if optimizer_process.stderr or optimizer_process.returncode != 0:
                # Clean up temporary LegoNE and Wolfram files before returning error
                try:
                    os.remove(self.temp_legone_name)
                    os.remove(self.temp_wolfram_name)
                except:
                    pass
                stderr = optimizer_process.stderr
                if not stderr:
                    return "Unknown system-level error"
                return f"Unknown error: {stderr}"

            # If no errors, record the output and return None
            self.wolfram_output = optimizer_process.stdout
            self.approximation = get_approximation(self.wolfram_output)
            return None

        except Exception as e:
            # Catch any unexpected exceptions and return as unknown error
            return f"Unknown error: {str(e)}"

    def clear_temp_files(self):
        try:
            os.remove(self.temp_legone_name)
        except:
            pass
        try:
            os.remove(self.temp_wolfram_name)
        except:
            pass

    def eval(self, algo_code: str):
        # First generate legone code
        self.gen_legone_code(algo_code)

        # Then compile to wolfram code
        compile_error = self.gen_wolfram_code()
        if compile_error:
            return False, compile_error

        # Finally calculate approximation ratio
        calc_error = self.cal_approx()

        self.clear_temp_files()
        if calc_error:
            return False, calc_error

        return True, self.approximation


# class Evaluator
